package operation.sql.predefined.type;

import static operation.sql.predefined.type.GroupAndBinCountOperation.*;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import com.google.common.base.Objects;

import context.project.VisProjectDBContext;
import rdb.table.data.DataTableColumn;
import rdb.table.data.DataTableColumnName;
import rdb.table.data.DataTableSchema;
import sql.ResultSetUtils;
import sql.SQLStringUtils;
import sql.derby.TableContentSQLStringFactory;


/**
 * helper class to facilitate {@link GroupAndBinCountOperation} to 
 * 1. process the ResultSet generated by the sql query that group and sort the input record data table;
 * 2. populate the output record data table
 * 
 * @author tanxu
 *
 */
class GroupAndBinCountOperationSqlResultSetProcessor {
	public static final int BATCH_SIZE = 1000;
	
	///////////////////////////////////
	private final VisProjectDBContext hostVisProjectDBContext;
	private final DataTableSchema outputDataTableSchema;

	private final double binSize;
	private final Double binMin;
	private final Double binMax;
	private final boolean ascend;
	
	private final ResultSet rs;
	private final Map<DataTableColumnName, DataTableColumn> groupByColNameMap;
	private final DataTableColumn binnedNumericCol;
	
	////////////////////////
	private Map<DataTableColumnName, String> currentGroupGroupByColStringValMap = null;
	private Double currentGroupCurrentBinBoundary;
	private Integer currentGroupCurrentBinCount;
	
	private List<String> currentNonRUIDColumnUpperCaseNameListInDataTableSchema;
	private PreparedStatement ps;
	private int currentBatchSize=0;
	/**
	 * constructor
	 * @param binSize
	 * @param binMin
	 * @param binMax
	 * @param ascend
	 * @param rs
	 * @param groupByColNameMap
	 * @param binnedNumericCol
	 * @param hostVisProjectDBContext
	 * @param outputDataTableSchema
	 */
	GroupAndBinCountOperationSqlResultSetProcessor(
			VisProjectDBContext hostVisProjectDBContext,
			DataTableSchema outputDataTableSchema,
			
			double binSize, Double binMin, Double binMax, boolean ascend,
			
			ResultSet rs,
			Map<DataTableColumnName, DataTableColumn> groupByColNameMap,
			DataTableColumn binnedNumericCol
			){
		
		this.binSize = binSize;
		this.binMin = binMin;
		this.binMax = binMax;
		this.ascend = ascend;
		
		this.rs = rs;
		this.groupByColNameMap = groupByColNameMap;
		this.binnedNumericCol = binnedNumericCol;
		
		this.hostVisProjectDBContext = hostVisProjectDBContext;
		this.outputDataTableSchema = outputDataTableSchema;
	}
	
	/**
	 * invoked after the constructor
	 * @throws SQLException
	 */
	void perform() throws SQLException {
		this.buildPreparedStatement();
		this.processResultSet();
		this.postprocess();
	}
	
	
	/**
	 * 
	 * @throws SQLException
	 */
	private void buildPreparedStatement() throws SQLException {
		currentNonRUIDColumnUpperCaseNameListInDataTableSchema = new ArrayList<>(); //not including the RUID column since it is auto increment
		for(DataTableColumn col:this.outputDataTableSchema.getOrderedListOfNonRUIDColumn()) {
			currentNonRUIDColumnUpperCaseNameListInDataTableSchema.add(col.getName().getStringValue().toUpperCase());
		}
		
		ps = this.hostVisProjectDBContext.getDBConnection().prepareStatement(
				TableContentSQLStringFactory.buildInsertIntoPreparedStatementSqlString(
						SQLStringUtils.buildTableFullPathString(this.outputDataTableSchema.getSchemaName(), this.outputDataTableSchema.getName()), 
						currentNonRUIDColumnUpperCaseNameListInDataTableSchema
						)
				);
	}
	
	/**
	 * 
	 * @throws SQLException
	 */
	private void processResultSet() throws SQLException {
		while(rs.next()) {
			double numericColumnValue = Double.parseDouble(
					binnedNumericCol.getSqlDataType().getStringValue(rs, this.binnedNumericCol.getName().getStringValue())
				);
			Map<DataTableColumnName, String> groupByColNameStringValueMap = ResultSetUtils.getCurrentRecordColumnNameStringValueMap(rs, groupByColNameMap);
			
			
			if(!Objects.equal(currentGroupGroupByColStringValMap, groupByColNameStringValueMap)) {//new group is entered
				//first process any unprocess bin of previous group
				if(this.currentGroupCurrentBinBoundary!=null&&this.isInBinRegion(this.currentGroupCurrentBinBoundary)) {//there must be at least one unprocessed bin of previous group
					this.addToPreparedStatement();
					this.moveBoundaryOneBinAhead();
					//reset
					this.currentGroupCurrentBinCount=0;
					
					if(isExplicitlyBounded()) {//there is an explicit ending boundary
						//process any empty bins of previous group//
						while(isInBinRegion(this.currentGroupCurrentBinBoundary)) {
							this.addToPreparedStatement();
							this.moveBoundaryOneBinAhead();
							this.currentGroupCurrentBinCount=0;
						}
					}
//					this.currentGroupCurrentBinCount++;//?
				}
				
				//reset parameters for new group
				this.currentGroupGroupByColStringValMap = groupByColNameStringValueMap;
				
				this.currentGroupCurrentBinCount = 0;
				//
				if(this.ascend) {
					if(this.binMin!=null) {
						this.currentGroupCurrentBinBoundary = this.binMin;
					}else {
						this.currentGroupCurrentBinBoundary = numericColumnValue;
					}
				}else {
					if(this.binMax!=null) {
						this.currentGroupCurrentBinBoundary = this.binMax;
					}else {
						this.currentGroupCurrentBinBoundary = numericColumnValue;
					}
				}
				
			}
			
			//
			processBinnedNumericColVal(numericColumnValue);
				
		}
		
	}
	
	/**
	 * 
	 * @param val
	 * @throws SQLException
	 */
	private void processBinnedNumericColVal(double val) throws SQLException {
		if(isInBinRegion(val)) {
			//there must be a current bin
			if(this.isInCurrentBin(val)) {//still in current bin;
				this.currentGroupCurrentBinCount++;
			}else {//not in current bin
				//process previous bins;
				//first insert the current bin into PreparedStatement
				this.addToPreparedStatement();
				this.moveBoundaryOneBinAhead();
				this.currentGroupCurrentBinCount=0;
				
				while(!this.isInCurrentBin(val)) {//add empty bins between the previous bin and the bin of current binned col value;
					this.addToPreparedStatement();
					this.moveBoundaryOneBinAhead();
					this.currentGroupCurrentBinCount=0;
				}
				//the bin of the current binned column value is encountered, simply add to the bin count;
				this.currentGroupCurrentBinCount++;
			}
		}else {//bin col value not in bin region; in this case, there must be an explicit bin region ending boundary;
			if(this.isInBinRegion(this.currentGroupCurrentBinBoundary)) {// //at least one bin has not been processed
				this.addToPreparedStatement();
				this.moveBoundaryOneBinAhead();
				//reset
				this.currentGroupCurrentBinCount=0;
				//process any empty bins
				while(isInBinRegion(this.currentGroupCurrentBinBoundary)) {
					this.addToPreparedStatement();
					this.moveBoundaryOneBinAhead();
					this.currentGroupCurrentBinCount=0;
				}
			}else {//current group not entered bin region, simply skip
				//
			}
			
		}
		
	}
	
	/**
	 * whether there is an explicit ending boundary for bin region or not;
	 * @return
	 */
	private boolean isExplicitlyBounded() {
		if(this.ascend) {
			return this.binMax!=null;
		}else {
			return this.binMin!=null;
		}
	}
	
	
	/**
	 * check if the given val is in between the bin region defined by {@link #binMin} and {@link #binMax}
	 * @param val
	 * @return
	 */
	private boolean isInBinRegion(double val) {
		if(this.binMin==null) {
			if(this.binMax==null) {
				return true;
			}else {
				return val<this.binMax;
			}
		}else {
			if(this.binMax==null) {
				return val>binMin;
			}else {
				return val<this.binMax&&val>binMin;
			}
		}
	}
	
	/**
	 * check if the given val is in between the {@link #currentGroupCurrentBinBoundary} and the next bin boundary based on the {@link #ascend};
	 * @param val
	 * @return
	 */
	private boolean isInCurrentBin(double val) {
		return this.ascend?
				this.currentGroupCurrentBinBoundary+this.binSize>=val:this.currentGroupCurrentBinBoundary-this.binSize<=val;
	}
	
	/**
	 * move boundary one bin ahead;
	 * this method does not check if the new boundary is out of bin region or not;
	 */
	private void moveBoundaryOneBinAhead() {
		this.currentGroupCurrentBinBoundary = this.ascend?
				this.currentGroupCurrentBinBoundary+this.binSize:this.currentGroupCurrentBinBoundary-this.binSize;
	}
	
	
	/**
	 * insert the bin between {@link #currentGroupCurrentBinBoundary} and the new boundary with count equal to the {@link #currentGroupCurrentBinCount};
	 * the group by col values are {@link #currentGroupGroupByColStringValMap}
	 * @throws SQLException 
	 */
	private void addToPreparedStatement() throws SQLException {
		double otherBoundary;
		if(this.ascend) {
			if(this.binMax!=null) {
				if(this.currentGroupCurrentBinBoundary+this.binSize<=binMax) {
					otherBoundary = this.currentGroupCurrentBinBoundary+this.binSize;
				}else {
					otherBoundary = binMax;
				}
			}else {
				otherBoundary = this.currentGroupCurrentBinBoundary+this.binSize;
			}
		}else {
			if(this.binMin!=null) {
				if(this.currentGroupCurrentBinBoundary-this.binSize>=binMax) {
					otherBoundary = this.currentGroupCurrentBinBoundary-this.binSize;
				}else {
					otherBoundary = binMin;
				}
			}else {
				otherBoundary = this.currentGroupCurrentBinBoundary-this.binSize;
			}
		}
		
		
		//set group by col name values
		for(DataTableColumnName groupByColName:this.currentGroupGroupByColStringValMap.keySet()) {
			this.outputDataTableSchema.getColumn(groupByColName).getSqlDataType().setPreparedStatement(
					ps, 
					currentNonRUIDColumnUpperCaseNameListInDataTableSchema.indexOf(groupByColName.getStringValue().toUpperCase())+1, 
					currentGroupGroupByColStringValMap.get(groupByColName)
					);
		}
		
		//set bin related columns values
		this.outputDataTableSchema.getColumn(BIN_START_COLUMN.getName()).getSqlDataType().setPreparedStatement(
				ps, 
				currentNonRUIDColumnUpperCaseNameListInDataTableSchema.indexOf(BIN_START_COLUMN.getName().getStringValue().toUpperCase())+1, 
				Double.toString(this.currentGroupCurrentBinBoundary)
				);
		this.outputDataTableSchema.getColumn(BIN_END_COLUMN.getName()).getSqlDataType().setPreparedStatement(
				ps, 
				currentNonRUIDColumnUpperCaseNameListInDataTableSchema.indexOf(BIN_END_COLUMN.getName().getStringValue().toUpperCase())+1, 
				Double.toString(otherBoundary)
				);
		this.outputDataTableSchema.getColumn(BIN_COUNT_COLUMN.getName()).getSqlDataType().setPreparedStatement(
				ps, 
				currentNonRUIDColumnUpperCaseNameListInDataTableSchema.indexOf(BIN_COUNT_COLUMN.getName().getStringValue().toUpperCase())+1, 
				Integer.toString(this.currentGroupCurrentBinCount)
				);
		
		
		
		//////////////////////////////
		currentBatchSize++;
		ps.addBatch();
		
		if(currentBatchSize>BATCH_SIZE) {
			ps.executeBatch();
			ps.clearBatch();
			currentBatchSize = 0;
		}
		
	}
	
	
	/**
	 * must be invoked after the {@link #perform()} method to deal with any remaining query in the {@link #ps}
	 * @throws SQLException 
	 */
	void postprocess() throws SQLException {
		//process the last bin of last group which is unprocessed
		if(isInBinRegion(this.currentGroupCurrentBinBoundary))
			addToPreparedStatement();
		
		
		ps.executeBatch();
		ps.clearBatch();
		ps.close();
	}

}
